<html>
<head>
<title>Pico SSOCR</title>

<style>

.digit-canvas {
    border-style: solid; 
    border-width: 1px;
    margin-right: 1;
}

</style>

<script>

//////////////////////////////////////////////////////////
// Globals
//////////////////////////////////////////////////////////

const NBR_PIXELS_PER_SEGMENT_X = 3;
const NBR_PIXELS_PER_SEGMENT_Y = 3;

const NBR_SEGMENTS = 8; // Including background

const Segment = {
    Back: 0,
    Top: 1,
    TopLeft: 2,
    TopRight: 3,
    Middle: 4,
    BottomLeft: 5,
    BottomRight: 6,
    Bottom: 7
}

//////////////////////////////////////////////////////////
// Seven Segment Digit Drawing Class (graphical)
//////////////////////////////////////////////////////////
class SSDigitDrawing {
    offset = 5;  // From edge (like padding)
    space  = 2;  // Between segments
    width  = 40; // With of segment
    height = 14; // Height of segment

    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = this.canvas.getContext("2d");
        this.canvas.width  =   this.width + 2*this.offset + 2*this.space + this.height;
        this.canvas.height = 2*this.width + 2*this.offset + 4*this.space + this.height;
        this.segmentColor = new Array(NBR_SEGMENTS);
        this.segmentLineColor = new Array(NBR_SEGMENTS);
        this.segmentLineWidth = new Array(NBR_SEGMENTS);
        this.resetStyle();
        this.draw();
    }

    onClick(callback) {
        var o = this.offset;
        var s = this.space;
        var w = this.width;
        var h = this.height;
        this.canvas.addEventListener('mousedown', function (e) {
            var x = event.offsetX;
            var y = event.offsetY;
            var selected = Segment.Back;
            if ((y > o) && (y < (o+h)) && 
                (x > (o+h)) && (x < (o+h+w))) {
                selected = Segment.Top;
            } else if ((y > (o+h)) && (y < (o+h+w)) && 
                (x > o) && (x < (o+h))) {
                selected = Segment.TopLeft;
            } else if ((y > (o+h)) && (y < (o+h+w)) && 
                (x > (o+w+2*s)) && (x < (o+w+2*s+h))) {
                selected = Segment.TopRight;
            } else if ((y > (o+w+2*s)) && (y < (o+w+2*s+h)) && 
                (x > (o+h)) && (x < (o+h+w))) {
                selected = Segment.Middle;
            } else if ((y > (o+h+w)) && (y < (o+h+w+w)) && 
                (x > o) && (x < (o+h))) {
                selected = Segment.BottomLeft;
            } else if ((y > (o+h+w)) && (y < (o+h+w+w)) && 
                (x > (o+w+2*s)) && (x < (o+w+2*s+h))) {
                selected = Segment.BottomRight;
            } else if ((y > (o+2*w+4*s)) && (y < (o+2*w+4*s+h)) && 
                (x > (o+h)) && (x < (o+h+w))) {
                selected = Segment.Bottom;
            }
            callback(selected);
        }); 
    }

    setColor(segment, color) {
        this.segmentColor[segment] = color;
    }

    setLineColor(segment, color) {
        this.segmentLineColor[segment] = color;
    }

    setLineWidth(segment, width) {
        this.segmentLineWidth[segment] = width;
    }

    resetStyle() {
        for (var i = 0 ; i < NBR_SEGMENTS ; i++) {
            this.segmentColor[i] = "white";
            this.segmentLineColor[i] = "black";
            this.segmentLineWidth[i] = 1;
        }
        // Default no visible line in background
        this.segmentLineColor[Segment.Back] = this.segmentColor[Segment.Back];
    }

    draw() {
        var o = this.offset;
        var s = this.space;
        var w = this.width;
        var h = this.height;

        // Fill background (also clears at redraw)
        this.ctx.fillStyle=this.segmentColor[Segment.Back];
        this.ctx.strokeStyle = this.segmentLineColor[Segment.Back];
        this.ctx.lineWidth = this.segmentLineWidth[Segment.Back];
        this.ctx.rect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.fill();
        this.ctx.stroke();

        //////////////////////////////
        // Draw the segments

        // Top
        this.drawSegment(h/2+o+s, h/2+o,
                         false, Segment.Top);
        // Top left
        this.drawSegment(h/2+o, h/2+o+s,
                         true, Segment.TopLeft);
        // Top right
        this.drawSegment(h/2+o + w + 2*s, h/2+o+s,
                         true, Segment.TopRight);
        // Middle
        this.drawSegment(h/2+o+s, h/2+o + w + 2*s,
                         false, Segment.Middle);
        // Botton left
        this.drawSegment(h/2+o, h/2+o + w + 3*s,
                         true, Segment.BottomLeft);
        // Botton right
        this.drawSegment(h/2+o + w + 2*s, h/2+o + w + 3*s,
                         true, Segment.BottomRight);
        // Botton
        this.drawSegment(h/2+o+s, h/2+o + 2 * w + 4*s,
                         false, Segment.Bottom);
    }

    drawSegment(x, y, rotate, segment) {
        var ctx = this.ctx;
        var w = this.width;
        var h = this.height; 

        ctx.fillStyle = this.segmentColor[segment];
        ctx.strokeStyle = this.segmentLineColor[segment];
        ctx.lineWidth = this.segmentLineWidth[segment];
        ctx.beginPath();
        ctx.moveTo(x, y);
        if (rotate) {
            ctx.lineTo(x + h/2, y + h/2);
            ctx.lineTo(x + h/2, y + (w - h/2));
            ctx.lineTo(x, y + w);
            ctx.lineTo(x - h/2, y + (w - h/2));
            ctx.lineTo(x - h/2, y + h/2);
        } else {
            ctx.lineTo(x + h/2, y - h/2);
            ctx.lineTo(x + (w - h/2), y - h/2);
            ctx.lineTo(x + w, y);
            ctx.lineTo(x + (w - h/2), y + h/2);
            ctx.lineTo(x + h/2, y + h/2);
        }
        ctx.lineTo(x, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    drawDot(canvas) {
        var o = this.offset;
        var s = this.space;
        var w = this.width;
        var h = this.height;

        canvas.width  =  h + 2*o;
        canvas.height = this.canvas.height;
        var ctx = canvas.getContext("2d");
        ctx.fillStyle = "black";
        ctx.fillRect(o, canvas.height - o - h, h, h);
        
    }
}

//////////////////////////////////////////////////////////
// Seven Segment Digit Coordinates Class
//////////////////////////////////////////////////////////
class Coordinate {
    x = 0;
    y = 0;
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

class SSDigitCoordinates {
    segmentCoordinate = [];

    constructor() {
        for (var i = 0 ; i < NBR_SEGMENTS ; i++) {
            this.segmentCoordinate.push(undefined);
        }
    }

    getCoordinate(segment) {
        return this.segmentCoordinate[segment];
    }

    setCoordinate(segment, x, y) {
        this.segmentCoordinate[segment] = new Coordinate(x,y);
    }
}

class SSDigitCoordinateCollection {
    digits = [];
    decimalPosition = undefined;

    constructor(nbrIntegers, nbrDecimals) {
        for (var i = 0 ; i < (nbrIntegers+nbrDecimals) ; i++) {
            this.digits.push(new SSDigitCoordinates());
        }
        if (nbrDecimals > 0) {
            this.decimalPosition = nbrIntegers;
        }
    }

    getDigit(index) {
        return this.digits[index];
    }
}

//////////////////////////////////////////////////////////
// Seven Segment Digits
//////////////////////////////////////////////////////////
class SSDigits {
    digitDatas = [];
    digitDrawings = [];

    selectedDigitIndex = undefined;
    selectedSegment = undefined;

    constructor(parentId, nbrIntegers, nbrDecimals, imageId, imageCanvasId) {
        //////////////////////////////
        // Setup all Digits
        var parent = document.getElementById(parentId);
        for (var i = 0 ; i < (nbrIntegers+nbrDecimals) ; i++) {
            var canvas = document.createElement("canvas");
            canvas.setAttribute("class", "digit-canvas");
            parent.appendChild(canvas);
            var digitDrawing = new SSDigitDrawing(canvas);
            this.digitDrawings.push(digitDrawing);
            (function (i, self) {
                digitDrawing.onClick(function(segment) {
                    self.clickedDigitCallback(i, segment);
                });
            })(i, this);

            // Add decimal dot if needed
            if ((i == (nbrIntegers - 1)) && (nbrDecimals > 0)) {
                var dotCanvas = document.createElement("canvas");
                dotCanvas.setAttribute("class", "digit-canvas");
                parent.appendChild(dotCanvas);
                digitDrawing.drawDot(dotCanvas);
            }
        }

        //////////////////////////////
        // Setup image
        var img = document.getElementById(imageId);
        var canvas = document.getElementById(imageCanvasId);
        var ctx = canvas.getContext("2d");
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0, img.width, img.height);
        var self = this;
        canvas.addEventListener('mousedown', function (e) {
            self.clickedImageCallback(event.offsetX, event.offsetY);
        });

    }

    clickedDigitCallback(digitIndex, segment) {
        this.selectedDigitIndex = digitIndex;
        this.selectedSegment = segment;
        this.draw();
    }

    clickedImageCallback(x, y) {
        alert(x + " " + y);
    }

    draw() {
        for (var i = 0 ; i < this.digitDrawings.length ; i++) {
            var dd = this.digitDrawings[i];
            dd.resetStyle();
            if (this.selectedDigitIndex == i) {
                dd.setLineColor(this.selectedSegment , "red");
                dd.setLineWidth(this.selectedSegment , 3);
            }
            dd.draw();
        }
    }
}


//////////////////////////////////////////////////////////
// Functions
//////////////////////////////////////////////////////////
window.onload = function() {
    var nbrInts = parseInt(document.getElementById("integers").value);
    var nbrDec = parseInt(document.getElementById("decimals").value);
    var coordinates = new SSDigitCoordinateCollection(nbrInts, nbrDec);
    digits = new SSDigits("digits", nbrInts, nbrDec, "ss-image", "ss-canvas");
}
function test() {
    var img = document.getElementById("ss-image");
    var canvas = document.getElementById("ss-canvas");
    var ctx = canvas.getContext("2d");
    ctx.canvas.width = img.width;
    ctx.canvas.height = img.height;
    ctx.drawImage(img, 0, 0, img.width, img.height);
    canvas.addEventListener('mousedown', function (e) {
        drawMarker(ctx, event.offsetX, event.offsetY, "red");
        return;
        var imgD = ctx.getImageData(event.offsetX - Math.round(NBR_PIXELS_PER_SEGMENT_X/2),
                                    event.offsetY - Math.round(NBR_PIXELS_PER_SEGMENT_Y/2),
                                    NBR_PIXELS_PER_SEGMENT_X,
                                    NBR_PIXELS_PER_SEGMENT_Y);
        var canvasBg = document.getElementById("bakground-canvas-pixels");
        var ctxBg = canvasBg.getContext("2d");
        ctxBg.putImageData(imgD, 0, 0);
        // Calculate average red, green and blue value
        var pixels = imgD.data;
        var r = 0, g = 0, b = 0, count = 0;
        for (var i = 0; i < pixels.length; i+=4) {
            r += pixels[i];
            g += pixels[i+1];
            b += pixels[i+2];
            // i+3 gamma is no used
            count += 1;
        }
        r = r / count;
        b = b / count;
        g = g / count;
        var canvasCol = document.getElementById("bakground-canvas-color");
        var ctxCol = canvasCol.getContext("2d");
        var oldCol = ctxCol.fillStyle;
        ctxCol.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
        ctxCol.fillRect(0, 0, 1 ,1);
        ctxCol.fillStyle = oldCol;
    });
    digit1 = new SSDigit("digit-canvas");
    digit2 = new SSDigit("digit-canvasB");
    digit2.setLineColor(Segment.Bottom, "red");
    digit2.setLineWidth(Segment.Bottom, 3);
    digit2.draw();
    digit1.onClick(function (segment) {
        alert(segment);
    }); 
}

function drawMarker(ctx, x, y, color) {
    ctx.strokeStyle = color;

    // Horizontal
    ctx.beginPath();
    ctx.moveTo(x - NBR_PIXELS_PER_SEGMENT_X, y);
    ctx.lineTo(x + NBR_PIXELS_PER_SEGMENT_X, y);
    ctx.closePath(); 
    ctx.stroke();

    // Vertical
    ctx.beginPath();
    ctx.moveTo(x, y - NBR_PIXELS_PER_SEGMENT_Y);
    ctx.lineTo(x, y + NBR_PIXELS_PER_SEGMENT_Y);
    ctx.closePath();  
    ctx.stroke();
}


</script>
</head>
<body>
    <!-- Hidden just for storing the image -->
    <img src="multical_21.jpg" id="ss-image" style="display: none"></img>

    <div style="width: 500px; height: 500px; overflow: scroll; display: inline-block;">
        <canvas id="ss-canvas"></canvas>
    </div>
    <div style="display:inline-block; vertical-align:top;">
        <label for="integers">Integers:</label>
        <input type="number" id="integers" name="integers" min="1" max="10" value="5">
        <label for="decimals">Decimals:</label>
        <input type="number" id="decimals" name="decimals" min="1" max="10" value="3">
        <br>
        <div id="digits" style="display:inline-block; vertical-align:top;">
            <!--<canvas id="digit-canvas" class="digit-canvas"></canvas>
            <canvas id="digit-canvasB" class="digit-canvas"></canvas>-->
        </div>
        <br>
        <div style="border-style: solid;">
            Bakground
            <canvas id="bakground-canvas-pixels" style="border-style: solid; width: 30; height: 30; vertical-align:middle;" height="3" width="3"></canvas>
            <canvas id="bakground-canvas-color" style="border-style: solid; width: 30; height: 30; vertical-align:middle;" height="1" width="1"></canvas>
        </div>
    </div>
</html>
